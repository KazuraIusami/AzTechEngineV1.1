<!DOCTYPE html>
<html>

	<head>
	<style>
	
		body {
			background-image: url('Background.png');
			background-size: inherit;
		}
		
	.sprite {
		position: absolute;
		background-size: cover;
		background-position: center;
		z-index: 0;
	}
		
	.tooltip {
        visibility: hidden;
        width: 120px;
        background-color: black;
        color: #fff;
        text-align: center;
        border-radius: 6px;
        padding: 5px;
        position: absolute;
        z-index: 1;
        bottom: 100%;
        left: 50%;
        margin-left: -60px;
        /* center the tooltip */
        opacity: 0;
        transition: opacity 1s;
    }

    .sprite:hover .tooltip {
        visibility: visible;
        opacity: 1;
    }
	
	
	.contextMenu {
		position: absolute;
		bottom:0;
		right:30px;
		width:30%;
		height:30%;
		margin: 20px;
		background-color: #7C7C7C;
		color: black;
		opacity: 0.5;
		z-index: 1;
		transition: opacity 1s, background-color 1s, color 1s;
		
		z-index: 2;
		
	}
	.contextMenu:hover {
		background-color: #3D3D3D;
		color: white;
		opacity: 1;
	}
	.contextMenu, p {
		padding: 15px;
	}
	
	.overlayDisplay {
		position:absolute;
		bottom: 0px;
		right: 0px;
		width: 100%;
		height: 100%;
		background-color: #7C7C7C;
		opacity: 70%;
		z-index: 4;
		
	}
	.InvDisplay {
		position : absolute;
		left : 50px;
		bottom : 50px;
		width:30%;
		height:30%;
		background-color: #7c7c7c;
		padding: 5px;
		opacity: 70%;
		display: inline;
		z-index: 2;
	}
	.slot {
		width: 30%;
		height: 30%;
		background-color: #9B9B9B;
		text-align: center;
		margin: 5px;
		display: inline;
	}
		
		
	</style>
	</head>
	
	<body>
	
	<script>
	
	//CONVERSATION TREES
		let PreLoad = {
			name: "Thank you!",
			start: {
				text: "For a better experience, please press F11 to go fullscreen. <br> Press Escape to open the Dev Menu, then Press 'Spawn Player.' Then, press 'BAR ROOM', I really hope you enjoy!",
				options: []
			}
		}
		
		let BarTalk = {
			name: "Wendigo",
			start: {
				text: "Couldnt stay away from the drink, huh?",
				options: [	{text: "Who are you?", next: "wendigoLore"},
							{text: "How come I couldn't see you before?", next: "drunk"}]
			
			},
			wendigoLore: {
				text: "You know that little part of you that begs to be free? To do whatever it is you wish to do NOW? Heh...I know him all too well.",
				options: []
			},
			drunk: {
				text: "That spicy water you had seemed to have some effect on it, huh?",
				options: []
			}
		}
		
		let BeerTalk = {
			name: "B &Sigma; 3 R",
			start: {
				text: "Its easy to get over the taste when your mind is focused on...other things.",
				options: [	{text: "Take a drink", next: "drink"},
							{text: "Read label", next: "label"}]
			
			},
			drink: {
				text: "<i> You swig from the bottle, gulping down a small drink to avoid the taste.</i> <br> The burn sinks down your throat and spreads out in your stomach.",
				options: [{text: "Back", next: "start"}]
			},
			label: {
				text: "B &Sigma; 3 R",
				options: [{text: "Back", next: "start"}]
			
			}
		}
		let WhiskyTalk = {
			name: "Whisky",
			start: {
				text: "Fun fact: It is spelled differently based on where its from.",
				options: [	{text: "Take a drink", next: "drink"},
							{text: "Read label", next: "label"}]
			
			},
			drink: {
				text: "<i> You swig from the bottle, gulping down a small drink to avoid the taste.</i> <br> The burn sinks down your throat and spreads out in your stomach.",
				options: [{text: "Back", next: "start"}]
			},
			label: {
				text: "To make a long explanation short, whiskey (with an 'e') refers to grain spirits distilled in Ireland and the United States. Whisky (with no 'e') refers to Scottish, Canadian, or Japanese grain spirits.",
				options: [{text: "Back", next: "start"}]
			
			}
		}
		let WineTalk = {
			name: "7 Deadly Zins",
			start: {
				text: "A sinful blend indeed! ",
				options: [	{text: "Take a drink", next: "drink"},
							{text: "Read label", next: "label"}]
			
			},
			drink: {
				text: "<i> You swig from the bottle, gulping down a small drink to avoid the taste.</i> <br> The burn sinks down your throat and spreads out in your stomach.",
				options: [{text: "Back", next: "start"}]
			},
			label: {
				text: "A sinful blend indeed! This labels art was pretty much ripped straight from a real wine brand.",
				options: [{text: "Back", next: "start"}]
			
			}
		}
		let RumTalk = {
			name: "Poizin",
			start: {
				text: "The Wine To Die For!",
				options: [	{text: "Take a drink", next: "drink"},
							{text: "Read label", next: "label"}]
			
			},
			drink: {
				text: "<i> You swig from the bottle, gulping down a small drink to avoid the taste.</i> <br> The burn sinks down your throat and spreads out in your stomach.",
				options: [{text: "Back", next: "start"}]
			},
			label: {
				text: "A sinful blend indeed! This labels art was pretty much ripped straight from a real wine brand.",
				options: [{text: "Back", next: "start"}]
			
			}
		}
		
		let conversationNode = "start";
		let conversationTree = PreLoad;
		
	//GLOBAL HELPERS
	
			const FRAMERATE  = 16; //AMOUNT OF MILLISECONDS BETWEEN CYCLES 16 = 60fps
			
			function isFullscreen(){
				return(window.innerHeight == screen.height);
			};
			
			function getRandomfromInt(max){
				return Math.floor(Math.random() * max);
			}
			
			
			function mergeInventoryArrays(arr1, arr2) {
				// Loop through each item in the second array
				arr2.forEach(item2 => {
					// Check if the item already exists in the first array
					const existingItem = arr1.find(item1 => item1.name === item2.name);

					if (existingItem) {
						// If the item already exists, merge the quantities
						existingItem.quantity += item2.quantity;
					} else {
						// If the item does not exist, add it to the first array
						arr1.push({ name: item2.name, quantity: item2.quantity });
					}
				});

				return arr1;
			}
			
	//CONTROLS

		let WASDcontrols = {moveUp : "w",
						moveDown: "s",
						moveLeft: "a",
						moveRight: "d"};
						
		let ArrowControls = {moveUp : "arrowup",
						moveDown: "arrowdown",
						moveLeft: "arrowleft",
						moveRight: "arrowright"};
						
		let activeControls = WASDcontrols;
		
		let mapLimits = {xMax: screen.width, xMin: 0, yMax: screen.height, yMin: 0};
		
	//ENTITY CLASS		
	
			let EntityList = [];
			let CollisionArray = [];
			
			class Entity {
				constructor(urlFolder, x, y, size, type, name){
				this.urlFolder = urlFolder;
				this.url = this.urlFolder + "/Front.gif";
				
					
				this.size = size; //Resolution of the sprite, width = size; height = size;
				this.x = x;
				this.y = y;
				this.type = type;	
				this.name = name;	//this will be the elements ID in the html
				this.velocity = {x: 0, y: 0};
				this.targetedPos = { x : 0, y : 0};
				this.moveSpeed = 0.5;
				this.distanceToTarget = {x: Math.abs(this.x - this.targetedPos.x), y: Math.abs(this.y - this.targetedPos.y)};
				
				this.facedDirection = "Back";
					
				this.onclickEnabled = false;
				
				this.wireFrameEnabled = true;
					
				this.attackPower = getRandomfromInt(10);
				this.healthPoints = getRandomfromInt(1000);
				
				this.conversationTree = PreLoad;
				
				this.inventory = []; //Inventory Array
				
				
				//THE ENTITY AUTOMATICALLY SPAWNS WHEN IT IS CALLED
					this.spawn();
				}
				
				spawn(){
				
				//creating the sprite
					const newSprite = document.createElement("div");
					newSprite.className = "sprite";
					this.SpriteInterval = setInterval( () => {
						newSprite.style.width = this.size + "px";
						newSprite.style.height = this.size + "px";
						newSprite.style.backgroundImage = 'url("' + this.url + '")';
					}, FRAMERATE);
					
					newSprite.style.top = this.y + "px";
					newSprite.style.left = this.x + "px";
					
					//Creating a tooltip attached to the Sprite with an onhover event inherited by the class
					
					 const tooltip = document.createElement("div");
					tooltip.className = "tooltip";
					newSprite.appendChild(tooltip);
					
					
					document.body.appendChild(newSprite);
					newSprite.setAttribute("id", this.name);

					
					console.log("Spawned " + this.name)
					
					newSprite.addEventListener("mousedown", () => {
								if(this.type === "Player"){
									this.toggleOnclick();
											document.addEventListener('mousemove', (event) => {
											const mouseX = event.clientX;
											const mouseY = event.clientY;
											// You can use mouseX and mouseY wherever needed in your code
												if(this.onclickEnabled){
												this.targetedPos = { x: mouseX - this.size / 2, y: mouseY - this.size / 2 };
												};
											});
									
								}
								
								if(this.type === "Monster"){
									this.healthPoints -= EntityList[0].attackPower;
									
										//TO DO: make this take into account both entities locations, check to see if they are within "combat range," if yes, attack, if no, dont.
								}
					});
					this.toolTipInterval = setInterval( () => {
								tooltip.innerHTML = " ' " + this.name 
											+ "' <br> HP : " + this.healthPoints 
											+ " <br> X: " + Math.floor(this.x) + " <br> Y: " + Math.floor(this.y) 
											+ "<br> Distance: " + Math.floor(this.distanceToTarget.x) + " " 
											+ Math.floor(this.distanceToTarget.y) + "<br> TYPE: " + this.type +  " <br> ATTACK: " + this.attackPower ;
					}, FRAMERATE);
					
					this.moveInterval = setInterval(() => { 
					
									//We want to hang on to the last position intervals in case the player wants to make a move they shouldnt be able to	
										//In other words,when the player walks into a wall, we ARE letting them try to change their location, but	
										//if that location isnt valid, set the current pos to the last pos
								this.lastPos = {x: this.x, y: this.y};
								
									//Then we set the position to the current position plus velocity values
								
								this.x += this.velocity.x; this.y += this.velocity.y; 
								
									//Check if the new position is inside the map limits
								
								if(this.x > mapLimits.xMax || this.x < mapLimits.xMin){
									this.x = this.lastPos.x;
								};
								
								if(this.y > mapLimits.yMax || this.y < mapLimits.yMin){
									this.y = this.lastPos.y;
								};
								
									//COLLISION CHECK
								
									for(let i = 0; i < EntityList.length; i++){
										if(EntityList[i].name === this.name){
											//The entity we are comparing is the same, so dont do anything
											
										}else if( this.checkCollision( EntityList[i]) ){
										
										
												this.x = this.lastPos.x;
												this.y = this.lastPos.y;
												
												EntityList[i].x = EntityList[i].lastPos.x;
												EntityList[i].y = EntityList[i].lastPos.y;
												
												this.targetedPos.x = this.x;
												this.targetedPos.y = this.y;
												
												
												
												
												if(this.type === "Player"){
													if(EntityList[i].type === "Monster"){
														console.log("Interacting with Monster");
														//"Fuck it lets make em fight" -Satoshi Tajiri
														<!-- this.healthPoints -= EntityList[i].attackPower; -->
														<!-- EntityList[i].healthPoints -= this.attackPower; -->
															this.targetedEntity = EntityList[i];
															<!-- console.log(this.targetedEntity); -->
															this.startAttack(this.targetedEntity);
														
														if(this.healthPoints <= 0){
																console.log("Player has died");
														};
														
													};
													
													if(EntityList[i].type === "NPC"){
														console.log("Interacting with NPC");
														 //"only when a mosquito lands om your testicle, will you realise theres a way to solve a problem without using violence" -Confusius
														 if(conversationTree != EntityList[i].conversationTree){
														 conversationNode = "start";
														 conversationTree = EntityList[i].conversationTree;
														 UpdateConversationDisplay();
														 }
														
													};
												};
												
										};
									};
										
								this.distanceToTarget = {x: Math.abs(this.x - this.targetedPos.x), y: Math.abs(this.y - this.targetedPos.y)};
								this.updatePos() }, FRAMERATE); //So this says "Move it by velocity everytime"
					
					this.directionInterval = setInterval(() => {
						// Change velocity toward the target
						if (this.x < this.targetedPos.x) {
							this.velocity.x = this.moveSpeed;
						} else if (this.x > this.targetedPos.x) {
							this.velocity.x = this.moveSpeed * -1;
						}else {
							
							this.velocity.x = 0;
						}

						if (this.y < this.targetedPos.y) {
							this.velocity.y =  this.moveSpeed;
						} else if (this.y > this.targetedPos.y) {
							this.velocity.y =  this.moveSpeed * -1;
						} else {
							this.velocity.y = 0;
						}

						// Change faced direction
						if (Math.abs(this.distanceToTarget.x) > Math.abs(this.distanceToTarget.y)) {
							if (this.targetedPos.x > this.x) {
								this.facedDirection = "Right";
								this.url = this.urlFolder + "/" + this.facedDirection + ".gif";
							} else if (this.targetedPos.x < this.x) {
								this.facedDirection = "Left";
								this.url = this.urlFolder + "/" + this.facedDirection + ".gif";
							}
						} else if (Math.abs(this.distanceToTarget.y) > Math.abs(this.distanceToTarget.x)) {
							if (this.targetedPos.y > this.y) {
								this.facedDirection = "Front";
								this.url = this.urlFolder + "/" + this.facedDirection + ".gif";
							} else if (this.targetedPos.y < this.y) {
								this.facedDirection = "Back";
								this.url = this.urlFolder + "/" + this.facedDirection + ".gif";
							}
						} else if(this.healthPoints > 1) { 
							this.url = this.urlFolder + "/idle/" + this.facedDirection + ".gif";
						}else if(this.healthPoints <= 0){
							this.url = this.urlFolder + "/death/" + this.facedDirection + ".gif";
							
						}
					}, FRAMERATE);
					
							
				}
				
				distanceToEntity(target){
					const x1 = this.x;
					const y1 = this.y;
					const x2 = target.x;
					const y2 = target.y;

						// Calculate the distance using the distance formula
				  const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));

				  // Check if the distance is within the threshold
				  return distance;

				}
				
				startAttack(target){
				
					//So theres a little trick going on here, when the startAttack function is called we are saving the DistanceToTarget as a const variable
					//And then we are just checking to see if the distance to target has exceeded that amount plus 50 
					//The reason we do this, is because certain entities have different sizes and it is therefore a different distance when you are on the right hand side 
					
				const startDistance = this.distanceToEntity(target);
				
				if(this.attackInterval){
					console.log("Already Fighting...");
				}else {
					this.attackInterval = setInterval(() => { 
							
						if(this.distanceToEntity(target) < startDistance+50){
							target.healthPoints -= this.attackPower;
							this.healthPoints -= target.attackPower;
							console.log()
								if(target.healthPoints < 0){	
								
									//LOOTING
									mergeInventoryArrays(this.inventory, target.inventory);
									
									
									InventoryUI.update(EntityList[0]);
									target.type = "Corpse";
									clearInterval(this.attackInterval);
									this.attackInterval = false;
								}
								if(this.healthPoints < 0){
									clearInterval(this.attackInterval);
									this.attackInterval = false;
								}
						}else {
							clearInterval(this.attackInterval);
							this.attackInterval = false;
						}
						
					}, 500);
				}
					
				}
				
				remove(){
					const elementToRemove = document.getElementById(this.name);
					if (elementToRemove) {
						elementToRemove.parentNode.removeChild(elementToRemove);
							clearInterval(this.toolTipInterval);
							clearInterval(this.SpriteInterval);
							clearInterval(this.moveInterval);
							clearInterval(this.directionInterval);
							clearInterval(this.keyBoardInterval);
							clearInterval(this.deathInterval);
							clearInterval(this.attackInterval)
						}
						 // Remove the entity from the EntityList
							const index = EntityList.findIndex(entity => entity.name === this.name);
							if (index !== -1) {
								EntityList.splice(index, 1);
							}
				}
				
				updatePos(){
					const targeted = document.getElementById(this.name);
						
					targeted.style.top = this.y + "px";
					targeted.style.left = this.x + "px";
					
				}
				
				toggleOnclick(){				//Click Sprite once,it follows the mouse. Click again, stops following
					if (this.onclickEnabled) {
						this.onclickEnabled = false; 
					} else {
						this.onclickEnabled = true; 
					}
				}
				toggleHitBox(){
					if(this.wireFrameEnabled){
						this.wireFrameEnabled = false;
						document.getElementById(this.name).style.border = "none";
					}else {
						this.wireFrameEnabled = true;
						document.getElementById(this.name).style.border = "1px solid black";
					}
				
					
				}
				
				checkCollision(otherEntity) {
					const hitboxReductionPercentage = 0.5; // Adjust this value to reduce the hitbox by a certain percentage

					// Calculate hitbox size for the current entity
					const hitboxWidthReduction = this.size * (1 - hitboxReductionPercentage);
					const hitboxHeightReduction = this.size * (1 - hitboxReductionPercentage);

					// Calculate hitbox size for the other entity
					const otherHitboxWidthReduction = otherEntity.size * (1 - hitboxReductionPercentage);
					const otherHitboxHeightReduction = otherEntity.size * (1 - hitboxReductionPercentage);

					const rect1 = {
						x: this.x + hitboxWidthReduction / 2,
						y: this.y + hitboxHeightReduction / 2,
						width: this.size - hitboxWidthReduction,
						height: this.size - hitboxHeightReduction
					};

					const rect2 = {
						x: otherEntity.x + otherHitboxWidthReduction / 2,
						y: otherEntity.y + otherHitboxHeightReduction / 2,
						width: otherEntity.size - otherHitboxWidthReduction,
						height: otherEntity.size - otherHitboxHeightReduction
					};

					if (
						rect1.x < rect2.x + rect2.width &&
						rect1.x + rect1.width > rect2.x &&
						rect1.y < rect2.y + rect2.height &&
						rect1.y + rect1.height > rect2.y
					) {
						// Collision detected
						return true;
					} else {
						return false;
					}
				}
				
				
			}
			
			//This function has been changed so that it does not clear the player.
				function clearEntities(){
					
						 for (let i = EntityList.length -1; i >= 1; i--) {
							// Assuming remove is a method you've defined in your Entity class
							if (EntityList[i] && typeof EntityList[i].remove === 'function') {
								EntityList[i].remove();
							}
						}
							// Add a confirmation or feedback for the user
							console.log("Room cleared.");
					
				}
			
			//ConversationMenu 
					  // Create the conversationDisplay div
				var conversationDisplay = document.createElement('div');
				conversationDisplay.id = 'conversationDisplay';
				conversationDisplay.className = "contextMenu";
				
				var moveButton = document.createElement("button");
				moveButton.id = "conversationMoveButton";
				moveButton.textContent = "[^]";
				
				moveButton.style.position = "absolute";
				moveButton.style.top = 0 + "px";
				moveButton.style.left = 0 + "px";

				// Create the Prompt element
				var prompt = document.createElement('span');
				prompt.textContent = 'Prompt';

				// Create the Options element
				var optionsDisplay = document.createElement('span');
				optionsDisplay.textContent = 'Options';

				// Append the span elements to the conversationDisplay div
				conversationDisplay.appendChild(moveButton);
				conversationDisplay.appendChild(prompt);
				conversationDisplay.appendChild(optionsDisplay);

				// Append the conversationDisplay div to the body
				document.body.appendChild(conversationDisplay);
				
				conversationDisplay.OnclickEnabled = false;
				
				
				//Move Conversation Display by pressing the button
				moveButton.onmousedown = function(){
					console.log("Moving Conversation Display");
						if(conversationDisplay.OnclickEnabled){
						conversationDisplay.OnclickEnabled = false;
						}else {
						conversationDisplay.OnclickEnabled = true;
						}
						document.addEventListener('mousemove', (event) => {
									const mouseX = event.clientX;
									const mouseY = event.clientY;
									
									
									
									// You can use mouseX and mouseY wherever needed in your code
										if(conversationDisplay.OnclickEnabled){
											conversationDisplay.style.top = (mouseY-25) + "px";
											conversationDisplay.style.left = (mouseX-25) + "px";
										}
													
						});
					
				}
				
				
				
				
				//Update the Conversation Display (PREVIOUSLY UpdateUI() )
				function UpdateConversationDisplay(){
					prompt.innerHTML = conversationTree.name + " <br> " + conversationTree[conversationNode].text + "<br>";
					
					//Remove all current nodes of options display
					while(optionsDisplay.hasChildNodes()){
							optionsDisplay.removeChild(optionsDisplay.firstChild);
						};

					//Create the new ones
					for(let i = 0; i < conversationTree[conversationNode].options.length; i++){
						const button = document.createElement("button");
						button.innerHTML = conversationTree[conversationNode].options[i].text;
						button.setAttribute('id', "option"+i);
						button.setAttribute('class', 'optionclass')
						
						optionsDisplay.appendChild(button);
						
						button.addEventListener("click",function(){
							conversationNode = conversationTree[conversationNode].options[i].next;
							UpdateConversationDisplay();
						});
					
					};
				};
				
				conversationTree = PreLoad;
				UpdateConversationDisplay();
				
			
				
				
			//Inventory class	
				class InventoryDisplay {
				
					constructor(){
						this.Display = document.createElement("div");
						this.Display.id = "inventoryDisplay"
						
						this.DisplayElement = document.createElement("div");
						
						this.Display.className = "InvDisplay";
						
						
						var moveInvButton = document.createElement("button");
						moveInvButton.id = "inventoryMoveButton";
						moveInvButton.textContent = "[^]";
						
						moveInvButton.style.position = "absolute";
						moveInvButton.style.top = 0 + "px";
						moveInvButton.style.left = 0 + "px";
						
						this.OnclickEnabled = false;
				
							
							//Move Conversation Display by pressing the button
							moveInvButton.onmousedown = () => {
								console.log("Moving Inventory Display");
									if(this.OnclickEnabled){
									this.OnclickEnabled = false;
									}else {
									this.OnclickEnabled = true;
									}
									document.addEventListener('mousemove', (event) => {
												const mouseX = event.clientX;
												const mouseY = event.clientY;
												
												
												
												// You can use mouseX and mouseY wherever needed in your code
													if(this.OnclickEnabled){
														this.Display.style.top = (mouseY-5) + "px";
														this.Display.style.left = (mouseX-5) + "px";
													}
																
									});
								
							}
									
							
						document.body.appendChild(this.Display);
						this.Display.appendChild(moveInvButton);
						this.Display.appendChild(this.DisplayElement);						
					}
					
					update(targetInventory) {
						this.DisplayElement.innerHTML = "<br>INVENTORY OF " + targetInventory.name + "<br>";
						for (let j = 0; j < targetInventory.inventory.length; j++) {
							this.DisplayElement.innerHTML += " <div class='slot'> " + targetInventory.inventory[j].name + " ( " + targetInventory.inventory[j].quantity + " ) </div> ";
						}
					}
				
				}
				let InventoryUI = new InventoryDisplay();
				
				function spawnPlayer(){
					if (EntityList[0]) {
								console.log("Player already spawned.");
							} else {
								// Spawn player sprite as EntityList[0]
								EntityList[0] = new Entity("Eugene", 771, 319, 400, "Player", "Eugene");
								EntityList[0].targetedPos = { x: EntityList[0].x, y: EntityList[0].y };
								
								
								
								EntityList[0].inventory.push( {name: "Gold", quantity: getRandomfromInt(100)});
								
								
								InventoryUI.update(EntityList[0]);
								
								EntityList[0].deathInterval = setInterval(() => {
									if(EntityList[0].healthPoints < 0){
										//Show death zone
											
											DeathRoom.generate();
											
											conversationTree = deathConversation;
											conversationNode = "start";
											UpdateConversationDisplay();
											clearInterval(EntityList[0].deathInterval);
									}
								}, FRAMERATE);
								
								EntityList[0].keyBoardInterval = setInterval( () => {
									if(pressedKeys[activeControls.moveUp]){
										EntityList[0].targetedPos.y = EntityList[0].y - 20;
									}
									if(pressedKeys[activeControls.moveDown]){
										EntityList[0].targetedPos.y = EntityList[0].y + 20;
									}
									if(pressedKeys[activeControls.moveLeft]){
										EntityList[0].targetedPos.x = EntityList[0].x - 20;
									}
									if(pressedKeys[activeControls.moveRight]){
										EntityList[0].targetedPos.x = EntityList[0].x + 20;
									}
									
									if(pressedKeys["SHIFT"]){
										EntityList[0].moveSpeed = 3;
									}else {
										EntityList[0].moveSpeed = 1;
									}
										for(let i = 0; i < pressedKeys.length; i++){
											pressedKeys[i] = false;
										}
									
								}, FRAMERATE);
					
							};
				};
				
				
				
				
				//The room class is a subclass of Entity class.  This is kind of important, because this class is dependant on the entity class to spawn .
				
				let currentRoom = "void";
				
				class room {
					constructor(imgUrl, outerLimits, EntitiesToSpawn, SpawnPoint, staticCollisions, roomName){
						this.imgUrl = imgUrl;
						this.outerLimits = outerLimits;
						this.EntitiesToSpawn = EntitiesToSpawn;
						this.SpawnPoint = SpawnPoint;
						if(staticCollisions){
							this.staticCollisions = staticCollisions;
						};
						
						
						this.roomName = roomName;
						
						
						this.doorsArray = []; //THE DOORS ARRAY IS NOT IN THE GENERATE METHOD BECAUSE I WANT TO ACCESS IT BEFORE GENERATING EVERY ROOM
						
						
					}
					generate(){
						
						//Apparently I dont already have a variable for global room declaration? 
							currentRoom = this.roomName;
						
						clearEntities();
						
						EntityList[0].x = this.SpawnPoint.x;
						EntityList[0].y = this.SpawnPoint.y;
						
						EntityList[0].targetedPos = { x: this.SpawnPoint.x, y: this.SpawnPoint.y };
						
						mapLimits = this.outerLimits;
						
							for(let i = 0; i < this.EntitiesToSpawn.length; i++){
								EntityList[i+1] = new Entity(	this.EntitiesToSpawn[i].urlFolder, 						//URL FOLDER
																this.EntitiesToSpawn[i].x, this.EntitiesToSpawn[i].y,	//Coordinates
																this.EntitiesToSpawn[i].size,							//Size
																this.EntitiesToSpawn[i].type,							//Type
																this.EntitiesToSpawn[i].name);							//Name
							//If TargetedPos is specified, set it to that. Otherwise, set it to current Pos.			
								if(this.EntitiesToSpawn[i].targetedPos){
									EntityList[i+1].targetedPos = {x: this.EntitiesToSpawn[i].targetedPos.x, y: this.EntitiesToSpawn[i].targetedPos.y};
								}else{
									EntityList[i+1].targetedPos = {x: this.EntitiesToSpawn[i].x, y: this.EntitiesToSpawn[i].y};
								}; 
							
							//If facedDirection is specified, set it to that. Otherwise, set it to front.
								if(this.EntitiesToSpawn[i].facedDirection){
									EntityList[i+1].facedDirection = this.EntitiesToSpawn[i].facedDirection;
								}else {
									EntityList[i+1].facedDirection = "front";
								}
								
							//If there is a specified inventory, set it to that. Otherwise, set it to a few gold? For now?
								if(this.EntitiesToSpawn[i].inventoryToSet){
									for(let k = 0; k < this.EntitiesToSpawn[i].inventoryToSet.length; k++){
										EntityList[i+1].inventory.push( {name: this.EntitiesToSpawn[i].inventoryToSet[k].name, quantity: this.EntitiesToSpawn[i].inventoryToSet[k].quantity} )
									}
								}else {
									EntityList[i+1].inventory.push( {name: "Gold", quantity: getRandomfromInt(100)} )
								}
								
								
								EntityList[i+1].conversationTree = this.EntitiesToSpawn[i].linkToConversationTree;
							}
							
							//Set the Z index of the player to be above everything else	
								document.getElementById(EntityList[0].name).style.zIndex = 1;
						
							this.staticCollisionsInterval = setInterval(() => {
								for(let i = 0; i < this.staticCollisions.length; i++){
									if(EntityList[0].x > this.staticCollisions[i].xMin && EntityList[0].x < this.staticCollisions[i].xMax){
										if(EntityList[0].y > this.staticCollisions[i].yMin && EntityList[0].y < this.staticCollisions[i].yMax){
											EntityList[0].x = EntityList[0].lastPos.x;
											EntityList[0].y = EntityList[0].lastPos.y;
										}
									}
								}
							}, FRAMERATE);
							
							
						
							<!-- if(this.doors){ -->
							<!-- this.doorInterval = setInterval(() => { -->
									<!-- for(let i = 0; i < this.doors.length; i++){ -->
										<!-- if(EntityList[0].x > this.doors[i].xMin && EntityList[0].x < this.doors[i].xMax){ -->
											<!-- if(EntityList[0].y > this.doors[i].yMin && EntityList[0].y < this.doors[i].yMax){  -->
												
												<!-- this.doors[i].room.generate(); -->
												<!-- clearInterval(this.doorInterval); -->
											<!-- } -->
										<!-- } -->
									<!-- } -->
								<!-- }, FRAMERATE); -->
							<!-- } -->
							
							
						
						document.body.style.backgroundImage = "url(" + this.imgUrl + ")";
						
					}
					addDoor(xMin, xMax, yMin, yMax, destination){
						this.doorsArray.push( setInterval( () => {
											if(EntityList[0].x > xMin && EntityList[0].x < xMax && EntityList[0].y > yMin && EntityList[0].y < yMax){
												destination.generate();
												
												for(let i = 0; i < this.doorsArray.length; i++){
													clearInterval(this.doorsArray[i]);
												}
											}
										},FRAMERATE) );
					}
				}
			
			let EmptyCollisions = [
				{xMin: 0, xMax: 1, yMin: 0, yMax: 1}
			];
			
		
			
			let EmptyEntitySet = [];
				
			let barEntities = [
					{urlFolder: "Wendigoo",
					x:176, y:191,
					size: 400,
					type:"NPC",
					name:"Wendigo",
					
					inventoryToSet: [{name: "Wendigo Chain", quantity: 1}],
					
					facedDirection: "right",
					linkToConversationTree: BarTalk
					},
					{urlFolder: "Beer",
					x:835, y:212,
					size: 200,
					type:"NPC",
					name:"Beer",
					
					facedDirection: "front",
					linkToConversationTree: BeerTalk
					},
					{urlFolder: "Whisky",
					x:1035, y:212,
					size: 200,
					type:"NPC",
					name:"Whisky",
					
					facedDirection: "front",
					linkToConversationTree: WhiskyTalk
					},
					{urlFolder: "Wine",
					x:1235, y:212,
					size: 200,
					type:"NPC",
					name:"Wine",
					
					facedDirection: "front",
					linkToConversationTree: WineTalk
					},
					{urlFolder: "Rum",
					x:1535, y:312,
					size: 200,
					type:"NPC",
					name:"Rum",
					
					facedDirection: "front",
					linkToConversationTree: RumTalk
					},
			];
			
			let barRoomCollision = [ 
				{xMin: 0, xMax: 1, yMin: 0, yMax: 1} //TABLE
			];
										
			let BarRoom = new room(
										"THEBAR.png", 							//BACKGROUND IMAGE
										{xMax: 1980, xMin: 0, yMax: 1200, yMin:0 }, //MAP LIMITS
										barEntities,								//ENEMY SET
										{x:552, y:475},							//SPAWN POINT
										barRoomCollision,						//STATIC COLLISIONS
										"Bar Room")								//NAME OF ROOM
										
			let BarRoomDark = new room(
										"THEBARDARK.png", 							//BACKGROUND IMAGE
										{xMax: 1980, xMin: 0, yMax: 1200, yMin:0 }, //MAP LIMITS
										barEntities,								//ENEMY SET
										{x:552, y:475},							//SPAWN POINT
										barRoomCollision,						//STATIC COLLISIONS
										"Bar Room Dark")								//NAME OF ROOM
										
			let AlleyWay = new room(
										"ALLEYWAY.png", 							//BACKGROUND IMAGE
										{xMax: 1980, xMin: 0, yMax: 1200, yMin:0 }, //MAP LIMITS
										EmptyEntitySet,								//ENEMY SET
										{x:552, y:475},							//SPAWN POINT
										EmptyCollisions,						//STATIC COLLISIONS
										"Alley",								//NAME OF ROOM
										[{xMin: 375, xMax: 500, yMin: 0, yMax: 259, room: BarRoom}])		//DOORS						
										
			let AlleyWaySide = new room(
										"ALLEYSIDE.png", 							//BACKGROUND IMAGE
										{xMax: 1980, xMin: 0, yMax: 1200, yMin:0 }, //MAP LIMITS
										EmptyEntitySet,								//ENEMY SET
										{x:552, y:475},							//SPAWN POINT
										EmptyCollisions,						//STATIC COLLISIONS
										"Alley Side")								//NAME OF ROOM
										
			let AlleyWayLong = new room(
										"AlleyWayLong.png", 							//BACKGROUND IMAGE
										{xMax: 1980, xMin: 0, yMax: 1200, yMin:0 }, //MAP LIMITS
										EmptyEntitySet,								//ENEMY SET
										{x:552, y:475},							//SPAWN POINT
										EmptyCollisions,						//STATIC COLLISIONS
										"Alley Long")								//NAME OF ROOM
										
				function linkDoors(){
				
					if(currentRoom === "Alley"){
						AlleyWay.addDoor(360, 550, 0, 246, BarRoom);
					}
					if(currentRoom === "Bar Room" || currentRoom === "Bar Room Dark"){
						BarRoom.addDoor(550, 850, 550, 900, AlleyWay);
					}
					
					
				}

						//TEMP VARIABLE
							let drunkMeter = 0;
			
											
			let DeathRoom = new room('DeathZone.png',  {xMax: screen.width, xMin: 0, yMax: screen.height, yMin: 0 }, EmptyEntitySet, {x: 750, y:320}, EmptyCollisions, "Death Zone");	//PLACE FOR DEATH				

			let roomContainer = [BarRoom, BarRoomDark, AlleyWay, AlleyWayLong];
			
			//DEV TOOLKIT
			
			class DevToolkit {
				
				constructor(){
					this.element = document.createElement("div");
					
					this.element.className = "overlayDisplay";
					
				//SPAWN PLAYER BUTTON
					this.spawnButton = document.createElement("button");
					
					
					this.spawnButton.innerHTML = "Spawn Player";
						this.spawnButton.addEventListener("click", spawnPlayer);
						
						
							
					this.element.appendChild(this.spawnButton);
					
			//ROOM SELECTOR
				this.roomSelector = document.createElement("select");
				this.roomSelector.id = "roomSelect";
				
				
					// Assuming roomContainer is an array of objects
				for (let i = 0; i < roomContainer.length; i++) {
				  let optionsElement = document.createElement("option");
				  optionsElement.text = roomContainer[i].roomName;
				  optionsElement.value = i; // Use the index as the value
				  this.roomSelector.appendChild(optionsElement);
				}

				this.roomSubmit = document.createElement("button");
				this.roomSubmit.innerHTML = "SUBMIT";
				this.roomSubmit.onclick = () => {
				  const selectedIndex = this.roomSelector.value;
				  const selectedRoom = roomContainer[selectedIndex];

				  if (selectedRoom && typeof selectedRoom.generate === 'function') {
					selectedRoom.generate();
				  } else {
					console.error("Invalid selection or generate method not found.");
				  }
				}

				this.element.appendChild(this.roomSubmit);
				this.element.appendChild(this.roomSelector);
						
			//ROOM BUTTONS GO HERE
				
				//BAR ROOM WITH LIGHTS
					this.barRoomButton = document.createElement("button");
					
					this.barRoomButton.innerHTML = "BAR ROOM";
					
					this.barRoomButton.onclick = () => {
						BarRoom.generate();
						
						let drinkingInterval = setInterval( () => {
									if(conversationNode === "drink"){
										drunkMeter += 0.1;
										conversationNode = "label";
										UpdateConversationDisplay();
										
									}
								}, FRAMERATE);
						
						let DrunkInterval = setInterval(() => {
									document.getElementById("Wendigo").style.opacity = drunkMeter;
								}, FRAMERATE);
					}
					this.element.appendChild(this.barRoomButton);
					
					
					//BAR ROOM WITH LIGHTS OFF
					this.barRoomDarkButton = document.createElement("button");
					
					this.barRoomDarkButton.innerHTML = "BAR ROOM (LIGHTS OFF)";
					
					this.barRoomDarkButton.onclick = () => {
						BarRoomDark.generate();
						
						let drinkingInterval = setInterval( () => {
									if(conversationNode === "drink"){
										drunkMeter += 0.1;
										conversationNode = "label";
										UpdateConversationDisplay();
										
									}
								}, FRAMERATE);
						
						let DrunkInterval = setInterval(() => {
									
									document.getElementById("Wendigo").style.opacity = drunkMeter;
								}, FRAMERATE);
					}
					this.element.appendChild(this.barRoomDarkButton);
					
					//ALLEY WAY
					this.AlleyButton = document.createElement("button");
					
					this.AlleyButton.innerHTML = "ALLEYWAY";
					
					this.AlleyButton.onclick = () => {
						AlleyWay.generate();
						
							let sideInterval = setInterval( () => {
								if(EntityList[0].x > 1500){
									clearInterval(doorInterval);
									clearInterval(sideInterval);
									
									AlleyWaySide.generate();
								}
							}, FRAMERATE)
								
							let doorInterval = setInterval( () => {
								if(EntityList[0].x > 370 && EntityList[0].x < 520 && EntityList[0].y > 0 && EntityList[0].y < 275){
									
									clearInterval(doorInterval);
									clearInterval(sideInterval);
									BarRoomDark.generate();
									
									let drinkingInterval = setInterval( () => {
										if(conversationNode === "drink"){
											drunkMeter += 0.1;
											conversationNode = "label";
											UpdateConversationDisplay();
										
										}
									}, FRAMERATE);
						
									let DrunkInterval = setInterval(() => {
										document.getElementById("Wendigo").style.opacity = drunkMeter;
									}, FRAMERATE);
								}
							}, FRAMERATE)
					}
					this.element.appendChild(this.AlleyButton);
					
				//LINK ROOMS BUTTON (THIS MIGHT BE TEMPORARY)
					this.LinkDoorsButton = document.createElement("button");
					
					this.LinkDoorsButton.innerHTML = "Link Rooms with doors (Experimental! Need to press in each room)";
					
					this.LinkDoorsButton.onclick = () => {
						linkDoors();
					};
					this.element.appendChild(this.LinkDoorsButton);
				
				//CLEAR ROOM
					
					this.clearButton = document.createElement("button");
					
					this.clearButton.innerHTML = "Clear All Entities";
					
					this.clearButton.onclick = () => {
						clearEntities();
					};
					
						this.element.appendChild(this.clearButton);
						
						
				//MOVEMENT button
					this.controlsButton = document.createElement("button");
					this.controlsButton.innerHTML = "CHANGE CONTROLS (WASD)";
					
					this.controlsButton.onclick = () => {
						
						if(activeControls === WASDcontrols){
							activeControls = ArrowControls;
							this.controlsButton.innerHTML = "CHANGE CONTROLS (ARROW)";
							console.log("Switched to Arrow Controls");
						}else {
							activeControls = WASDcontrols;
							this.controlsButton.innerHTML = "CHANGE CONTROLS (WASD)";
							console.log("Switched to WASD Controls");
						}
						
					};
					
					this.element.appendChild(this.controlsButton);
						
				//Turn on all wireframes
					this.wireFrameButton = document.createElement("button");
					
					this.wireFrameButton.innerHTML = "Show All Hitboxes";
					
					this.wireFrameButton.onclick = () => {
						for(let i = 0; i < EntityList.length; i++){
						//okay...so i am making it FALSE first because I am going to toggle it. That WILL be confusing and we WILL end up messing something up. Sucks to suck.
							EntityList[i].wireFrameEnabled = false;
							EntityList[i].toggleHitBox();
						}
					}
					
						this.element.appendChild(this.wireFrameButton);
					
					document.body.appendChild(this.element)
					
					
					
					this.isVisible = true;
					this.toggleVisibility();
				
				
				}
				
				toggleVisibility(){						//Visibility of the Dev Toolkit
					if (this.isVisible) {
						this.element.style.display = "none"; // hide the element
						this.isVisible = false; // update the visibility state
					} else {
						this.element.style.display = "block"; // show the element
						this.isVisible = true; // update the visibility state
					}
				}
				
				
					
					
				
			}
			let DevKit = new DevToolkit();
			
			
			//Add a keylog listener
			
			document.body.addEventListener("keydown", (event) => {
				console.log(event.key);
				
					if(event.key === "Escape"){
						DevKit.toggleVisibility();
					}
			});
			
			
			
			let pressedKeys = [];
			
			document.body.addEventListener("keydown", (event) => {
				
				pressedKeys[event.key.toUpperCase()] = true;
				pressedKeys[event.key.toLowerCase()] = true;
			});
			
			document.body.addEventListener("keyup", (event) => {
			
				pressedKeys[event.key.toUpperCase()] = false;
				pressedKeys[event.key.toLowerCase()] = false;
				
			})
	
	
			window.alert("Press Escape, press 'Spawn Player', press 'BAR ROOM'");
			
		</script>
	</body>

</html>

